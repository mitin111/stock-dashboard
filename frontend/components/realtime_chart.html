<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>
<style>
  body { margin:0; background:#000; overflow:hidden }
  #chart-container { width:100%; height:100vh; }
</style>
</head>
<body>
<div id="chart-container"></div>

<script>
// ---- Inputs from Streamlit ----
let history    = window.initialHistory || [];
let wsUrl      = window.wsUrl || ((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws/live');
let initialTok = window.initialToken || null;
let barIntMin  = Number(window.barInterval || 1); // 1/3/5/â€¦

// ---- Chart ----
const chart = LightweightCharts.createChart(document.getElementById('chart-container'), {
  layout: { background: { color: '#000' }, textColor: '#fff' },
  grid: { vertLines: { color: '#222' }, horzLines: { color: '#222' } },
  timeScale: {
    timeVisible: true,
    secondsVisible: false,
    rightOffset: 3,
    // âœ… Bottom axis IST labels
    tickMarkFormatter: (time /* number|{timestamp} */) => {
      const ts = (typeof time === 'object' && time.timestamp) ? time.timestamp : time;
      return new Date(ts * 1000).toLocaleString('en-IN', {
        timeZone: 'Asia/Kolkata', hour12: false, hour: '2-digit', minute: '2-digit',
        day: '2-digit', month: '2-digit'
      });
    },
  },
  crosshair: { mode: 1 },
  // âœ… Crosshair time string also IST
  localization: {
    timeFormatter: (ts) =>
      new Date((ts.timestamp ?? ts) * 1000).toLocaleString('en-IN', { timeZone: 'Asia/Kolkata', hour12: false })
  }
});

const candleSeries = chart.addCandlestickSeries({
  upColor:'#26a69a', downColor:'#ef5350', borderUpColor:'#26a69a', borderDownColor:'#ef5350',
  wickUpColor:'#26a69a', wickDownColor:'#ef5350'
});
candleSeries.setData(history);

// ---- Helper: bucket to interval in IST ----
function bucketToInterval(tsSec) {
  // tsSec is UTC seconds
  const dUTC = new Date(tsSec * 1000);
  // shift to IST (+5:30 = 330 min)
  const istMs = dUTC.getTime() + 330 * 60 * 1000;
  const ist = new Date(istMs);
  ist.setSeconds(0, 0);
  const m = ist.getMinutes();
  ist.setMinutes(Math.floor(m / barIntMin) * barIntMin);
  // shift back to UTC seconds
  const backUTCms = ist.getTime() - 330 * 60 * 1000;
  return Math.floor(backUTCms / 1000);
}

// ---- WebSocket ----
let ws = new WebSocket(wsUrl);

ws.onopen = () => {
  console.log("âœ… LW WS Connected:", wsUrl);
  // âœ… auto-subscribe current token
  if (initialTok) {
    try {
      ws.send(JSON.stringify({ action: "subscribe", tokens: [initialTok] }));
      console.log("ðŸ”” Subscribed to", initialTok);
    } catch (e) { console.log(e); }
  }
};

ws.onmessage = (event) => {
  try {
    const payload = JSON.parse(event.data);

    // Accept both flat and nested formats
    const p = payload.tick ? payload.tick : payload;

    const price = Number(p.lp || p.ltp || p.price);
    let ts = Number(p.ft || p.time || p.lts);

    if (!price || !ts) return;
    if (ts > 1e12) ts = Math.floor(ts / 1000); // ms -> s

    const tBucket = bucketToInterval(ts);

    candleSeries.update({
      time: tBucket,
      open: price, high: price, low: price, close: price
    });
  } catch (e) {
    console.log("âš ï¸ Tick parse error:", e);
  }
};

ws.onclose = () => {
  console.log("ðŸ”Œ WS Closed â€” Reconnecting in 2s...");
  setTimeout(() => location.reload(), 2000);
};
</script>
