<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Realtime Chart</title>

  <script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>

  <style>
    html, body { margin: 0; padding: 0; background: #000; overflow: hidden; }
    #price-chart { width: 100vw; height: 450px; }
    #macd-chart  { width: 100vw; height: 180px; margin-top:4px; }
  </style>
</head>

<body>

  <!-- PRICE CHART -->
  <div id="price-chart"></div>

  <!-- MACD CHART -->
  <div id="macd-chart"></div>

  <!-- Python will inject -->
  <script>
    /*INJECT_DATA*/
  </script>

<script>
/* ----------------------------------------
   Wait until Python injects history + wsUrl + token
-----------------------------------------*/
function waitForDataAndStart() {
  if (!window.initialHistory ||
      !Array.isArray(window.initialHistory) ||
      window.initialHistory.length === 0) {

    console.log("â³ Waiting for Python injection...");
    return setTimeout(waitForDataAndStart, 300);
  }
  startChart();
}
waitForDataAndStart();

/* ----------------------------------------
   MAIN CHART FUNCTION
-----------------------------------------*/
function startChart() {

  const history    = window.initialHistory || [];
  const wsUrl      = window.wsUrl || "wss://backend-stream-nmlf.onrender.com/ws/live";
  const initialTok = window.initialToken || "";
  const barIntMin  = Number(window.barInterval || 1);

  console.log("Injected history:", history.length);
  console.log("wsUrl:", wsUrl);
  console.log("initialToken:", initialTok);

  const safe = v => (v === null || v === undefined || isNaN(v) ? null : Number(v));

  /* ----------------------------------------
          ðŸ”µ TOP PRICE CHART
  ----------------------------------------*/
  const priceChart = LightweightCharts.createChart(
    document.getElementById('price-chart'),
    {
        layout: { background:{color:'#000'}, textColor:'#fff' },
        grid: { vertLines:{color:'#222'}, horzLines:{color:'#222'} },
        timeScale:{
            timeVisible:true,
            secondsVisible:false,
            timeZone:'Asia/Kolkata'
        }
    }
  );
  priceChart.applyOptions({
      timezone: 'Asia/Kolkata',
      localization: {
          locale: 'en-IN',
          timeFormatter: t =>
              new Date(t * 1000).toLocaleString('en-IN', {
                  timeZone: 'Asia/Kolkata',
                  hour12: false,
              }),
      },
      timeScale: {
          tickMarkFormatter: t =>
              new Date(t * 1000).toLocaleTimeString('en-IN', {
                  timeZone: 'Asia/Kolkata',
                  hour12: false,
                  hour: '2-digit',
                  minute: '2-digit',
              }),
      },
  });

  const candleSeries = priceChart.addCandlestickSeries({
    upColor:'#26a69a',
    downColor:'#ef5350',
    borderUpColor:'#26a69a',
    borderDownColor:'#ef5350',
    wickUpColor:'#26a69a',
    wickDownColor:'#ef5350'
  });

  const pacU = priceChart.addLineSeries({ color:'#808080', lineWidth:1 });
  const pacL = priceChart.addLineSeries({ color:'#808080', lineWidth:1 });
  const pacC = priceChart.addLineSeries({ color:'#00FFFF', lineWidth:2 });
  const trail1 = priceChart.addLineSeries({ color:'#FF00FF', lineWidth:1 });
  const trail2 = priceChart.addLineSeries({ color:'#00FFFF', lineWidth:1.5 });

 
  /* ----------------------------------------
          ðŸ”´ BOTTOM MACD CHART
  ----------------------------------------*/
 
  const macdChart = LightweightCharts.createChart(
      document.getElementById('macd-chart'),
      {
          layout:{ background:{color:'#000'}, textColor:'#fff' },
          grid:{ vertLines:{color:'#222'}, horzLines:{color:'#222'} },

          // â­ Correct India Time (IST)
          timeScale:{
              timeVisible:true,
              secondsVisible:false,
              timeZone:'Asia/Kolkata'
          },

          rightPriceScale:{ visible:true, autoScale:true },

          // ðŸ”¥ Allow user to move MACD chart
          handleScroll:{
              mouseWheel:true,
              pressedMouseMove:true
          },
          handleScale:{
              axisPressedMouseMove:true,
              mouseWheel:true,
              pinch:true
          }
      }
  );

  macdChart.applyOptions({
      timezone: 'Asia/Kolkata',
      localization: {
          locale: 'en-IN',
          timeFormatter: t =>
              new Date(t * 1000).toLocaleString('en-IN', {
                  timeZone: 'Asia/Kolkata',
                  hour12: false,
              }),
      },
      timeScale: {
          tickMarkFormatter: t =>
              new Date(t * 1000).toLocaleTimeString('en-IN', {
                  timeZone: 'Asia/Kolkata',
                  hour12: false,
                  hour: '2-digit',
                  minute: '2-digit',
              }),
      },
  });

  const macdHistSeries   = macdChart.addHistogramSeries({ base:0 });
  const macdLineSeries   = macdChart.addLineSeries({ color:'#00FFFF', lineWidth:1.5 });
  const macdSignalSeries = macdChart.addLineSeries({ color:'#FF00FF', lineWidth:1.5 });

  /* ----------------------------------------
     LOAD FULL HISTORY
  -----------------------------------------*/
  candleSeries.setData(history.map(c => ({
    time:c.time,
    open:c.open,
    high:c.high,
    low:c.low,
    close:c.close
  })));

  pacU.setData(history.map(c => ({ time:c.time, value:safe(c.pacU) })));
  pacL.setData(history.map(c => ({ time:c.time, value:safe(c.pacL) })));
  pacC.setData(history.map(c => ({ time:c.time, value:safe(c.pacC) })));
  trail1.setData(history.map(c => ({ time:c.time, value:safe(c.Trail1) })));
  trail2.setData(history.map(c => ({ time:c.time, value:safe(c.Trail2) })));

  macdHistSeries.setData(history.map(c => ({
    time:c.time,
    value:safe(c.macd_hist),
    color:(c.macd_hist >= 0 ? '#00FF00' : '#FF0000')
  })));

  macdLineSeries.setData(history.map(c => ({ time:c.time, value:safe(c.macd) })));
  macdSignalSeries.setData(history.map(c => ({ time:c.time, value:safe(c.macd_signal) })));

  // =============================
  // PERFECT 2-WAY SYNC SCROLL + ZOOM (NO LOCKING)
  // =============================

  let syncingFromPrice = false;
  let syncingFromMacd  = false;

  // PRICE â†’ MACD
  priceChart.timeScale().subscribeVisibleLogicalRangeChange((logicalRange) => {
      if (syncingFromMacd || !logicalRange) return;

      syncingFromPrice = true;
      try {
          macdChart.timeScale().setVisibleLogicalRange(logicalRange);
      } catch (e) {}
      syncingFromPrice = false;
  });

  // MACD â†’ PRICE
  macdChart.timeScale().subscribeVisibleLogicalRangeChange((logicalRange) => {
      if (syncingFromPrice || !logicalRange) return;

      syncingFromMacd = true;
      try {
          priceChart.timeScale().setVisibleLogicalRange(logicalRange);
      } catch (e) {}
      syncingFromMacd = false;
  });

  /* ----------------------------------------
     REALTIME WEBSOCKET HANDLING (STABLE)
  -----------------------------------------*/

  /* ----------------------------------------
     REALTIME WEBSOCKET HANDLING (FIXED)
  -----------------------------------------*/

  function bucket(ts) {
    return Math.floor(ts / (barIntMin * 60)) * (barIntMin * 60);
  }

  let lastBar = null;

  function connectWS() {
    if (!initialTok) {
      console.log("â›” No token â†’ cannot start WS");
      return;
    }

    console.log("ðŸ”Œ Connecting WS:", wsUrl);
    const ws = new WebSocket(wsUrl);

    ws.onopen = () => {
      console.log("ðŸ“¡ WS OPEN â†’ subscribingâ€¦");
      ws.send(JSON.stringify({ type: "subscribe", token: initialTok }));
    };

    ws.onmessage = (ev) => {
      let p;
      try { p = JSON.parse(ev.data); } catch (e) { return; }
      if (!p) return;

      const price = Number(p.lp ?? p.ltp ?? p.price);
      if (!price) return;

      let ts = Number(p.ft ?? p.time ?? p.lts);
      if (!ts) return;

      if (ts > 1e12) ts = Math.floor(ts / 1000);
      const t = bucket(ts);

      // ---- CANDLE CREATION ----
      if (!lastBar || t !== lastBar.time) {
        lastBar = { time: t, open: price, high: price, low: price, close: price };
        candleSeries.update(lastBar);
      } else {
        lastBar.high  = Math.max(lastBar.high, price);
        lastBar.low   = Math.min(lastBar.low,  price);
        lastBar.close = price;
        candleSeries.update(lastBar);
      }

      // ---- LIVE INDICATOR UPDATES ----
      if (p.pacU !== undefined) pacU.update({ time: t, value: p.pacU });
      if (p.pacL !== undefined) pacL.update({ time: t, value: p.pacL });
      if (p.pacC !== undefined) pacC.update({ time: t, value: p.pacC });

      if (p.tr1 !== undefined) trail1.update({ time: t, value: p.tr1 });
      if (p.tr2 !== undefined) trail2.update({ time: t, value: p.tr2 });

      if (p.macd_hist !== undefined)
        macdHistSeries.update({ time: t, value: p.macd_hist });

      if (p.macd !== undefined)
        macdLineSeries.update({ time: t, value: p.macd });

      if (p.macd_signal !== undefined)
        macdSignalSeries.update({ time: t, value: p.macd_signal });
    };

    ws.onclose = () => {
      console.log("âš  WS CLOSED â†’ retry in 1s");
      setTimeout(connectWS, 1000);
    };
  }

  if (initialTok) connectWS();


</script>

</body>
</html>


















