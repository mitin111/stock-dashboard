<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Realtime Chart</title>

  <script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>

  <style>
    html, body { margin: 0; padding: 0; background: #000; overflow: hidden; }
    #price-chart { width: 100vw; height: 450px; }
    #macd-chart  { width: 100vw; height: 180px; margin-top:4px; }
  </style>
</head>

<body>

  <!-- PRICE CHART -->
  <div id="price-chart"></div>

  <!-- MACD CHART -->
  <div id="macd-chart"></div>

  <!-- Python will inject -->

<script>

/* ----------------------------------------
   MAIN CHART FUNCTION
-----------------------------------------*/
function startChart() {

  const history    = window.initialHistory || [];
  const wsUrl      = window.wsUrl || "wss://backend-stream-nmlf.onrender.com/ws/live";
  const initialTok = window.initialToken || "";
  const barIntMin  = Number(window.barInterval || 1);

  console.log("Injected history:", history.length);
  console.log("wsUrl:", wsUrl);
  console.log("initialToken:", initialTok);

  const safe = v => (v === null || v === undefined || isNaN(v) ? null : Number(v));

  /* ----------------------------------------
          üîµ TOP PRICE CHART
  ----------------------------------------*/
  const priceChart = LightweightCharts.createChart(
    document.getElementById('price-chart'),
    {
        layout: { background:{color:'#000'}, textColor:'#fff' },
        grid: { vertLines:{color:'#222'}, horzLines:{color:'#222'} },
        timeScale:{
            timeVisible:true,
            secondsVisible:false,
            timeZone:'Asia/Kolkata'
        }
    }
  );
  priceChart.applyOptions({
      timezone: 'Asia/Kolkata',
      localization: {
          locale: 'en-IN',
          timeFormatter: t =>
              new Date(t * 1000).toLocaleString('en-IN', {
                  timeZone: 'Asia/Kolkata',
                  hour12: false,
              }),
      },
      timeScale: {
          tickMarkFormatter: t =>
              new Date(t * 1000).toLocaleTimeString('en-IN', {
                  timeZone: 'Asia/Kolkata',
                  hour12: false,
                  hour: '2-digit',
                  minute: '2-digit',
              }),
      },
  });

  const candleSeries = priceChart.addCandlestickSeries({
    upColor:'#26a69a',
    downColor:'#ef5350',
    borderUpColor:'#26a69a',
    borderDownColor:'#ef5350',
    wickUpColor:'#26a69a',
    wickDownColor:'#ef5350'
  });

  const pacU = priceChart.addLineSeries({ color:'#808080', lineWidth:1 });
  const pacL = priceChart.addLineSeries({ color:'#808080', lineWidth:1 });
  const pacC = priceChart.addLineSeries({ color:'#00FFFF', lineWidth:2 });
  const trail1 = priceChart.addLineSeries({ color:'#FF00FF', lineWidth:1 });
  const trail2 = priceChart.addLineSeries({ color:'#00FFFF', lineWidth:1.5 });

  // ===============================
  // ‚≠ê Yesterday High / Low Lines
  // ===============================
  const yHigh = priceChart.addLineSeries({
      color: "orange",
      lineWidth: 1,
      priceLineVisible: true,
      priceLineColor: "orange"
  });

  const yLow = priceChart.addLineSeries({
      color: "#00FFAA",
      lineWidth: 1,
      priceLineVisible: true,
      priceLineColor: "#00FFAA"
  });

 
  /* ----------------------------------------
          üî¥ BOTTOM MACD CHART
  ----------------------------------------*/
 
  const macdChart = LightweightCharts.createChart(
      document.getElementById('macd-chart'),
      {
          layout:{ background:{color:'#000'}, textColor:'#fff' },
          grid:{ vertLines:{color:'#222'}, horzLines:{color:'#222'} },

          // ‚≠ê Correct India Time (IST)
          timeScale:{
              timeVisible:true,
              secondsVisible:false,
              timeZone:'Asia/Kolkata'
          },

          rightPriceScale:{ visible:true, autoScale:true },

          // üî• Allow user to move MACD chart
          handleScroll:{
              mouseWheel:true,
              pressedMouseMove:true
          },
          handleScale:{
              axisPressedMouseMove:true,
              mouseWheel:true,
              pinch:true
          }
      }
  );

  macdChart.applyOptions({
      timezone: 'Asia/Kolkata',
      localization: {
          locale: 'en-IN',
          timeFormatter: t =>
              new Date(t * 1000).toLocaleString('en-IN', {
                  timeZone: 'Asia/Kolkata',
                  hour12: false,
              }),
      },
      timeScale: {
          tickMarkFormatter: t =>
              new Date(t * 1000).toLocaleTimeString('en-IN', {
                  timeZone: 'Asia/Kolkata',
                  hour12: false,
                  hour: '2-digit',
                  minute: '2-digit',
              }),
      },
  });

  const macdHistSeries   = macdChart.addHistogramSeries({ base:0 });
  const macdLineSeries   = macdChart.addLineSeries({ color:'#00FFFF', lineWidth:1.5 });
  const macdSignalSeries = macdChart.addLineSeries({ color:'#FF00FF', lineWidth:1.5 });

  /* ----------------------------------------
     LOAD FULL HISTORY
  -----------------------------------------*/
  const candlesData = history.map(c => ({
      time: c.time,
      open: c.open,
      high: c.high,
      low: c.low,
      close: c.close,
      color:
          c.trm_signal === 'Buy' ? '#00FF00' :
          c.trm_signal === 'Sell' ? '#FF0000' :
          '#808080'
  }));

  candleSeries.setData(candlesData);


  pacU.setData(history.map(c => ({ time:c.time, value:safe(c.pacU) })));
  pacL.setData(history.map(c => ({ time:c.time, value:safe(c.pacL) })));
  pacC.setData(history.map(c => ({ time:c.time, value:safe(c.pacC) })));
  trail1.setData(history.map(c => ({ time:c.time, value:safe(c.Trail1) })));
  trail2.setData(history.map(c => ({ time:c.time, value:safe(c.Trail2) })));

  // ====== YESTERDAY HIGH/LOW =======
  yHigh.setData(
      history
        .filter(c => c.high_yest !== null && !isNaN(c.high_yest) && c.high_yest > 0)
        .map(c => ({ time: c.time, value: Number(c.high_yest) }))
  );

  yLow.setData(
      history
        .filter(c => c.low_yest !== null && !isNaN(c.low_yest) && c.low_yest > 0)
        .map(c => ({ time: c.time, value: Number(c.low_yest) }))
  );

  macdHistSeries.setData(history.map(c => ({
    time:c.time,
    value:safe(c.macd_hist),
    color:(c.macd_hist >= 0 ? '#00FF00' : '#FF0000')
  })));

  macdLineSeries.setData(history.map(c => ({ time:c.time, value:safe(c.macd) })));
  macdSignalSeries.setData(history.map(c => ({ time:c.time, value:safe(c.macd_signal) })));

  /* -------------------------------------
     ‚≠ê VOLATILITY PANEL (TOP RIGHT)
  --------------------------------------*/

  const last = history[history.length - 1];
  let vol = last?.range_pct ?? null;

  if (vol !== null && !isNaN(vol)) {
      // Floating HTML tooltip-like label
      const panel = document.createElement("div");
      panel.style.position = "absolute";
      panel.style.top = "10px";
      panel.style.right = "10px";
      panel.style.padding = "6px 10px";
      panel.style.background = "rgba(0,0,0,0.6)";
      panel.style.color = "orange";
      panel.style.fontSize = "14px";
      panel.style.borderRadius = "4px";
      panel.style.zIndex = "50";
      panel.innerHTML = `üìä Volatility: ${vol.toFixed(2)}%`;
      document.getElementById("price-chart").appendChild(panel);
  }

  /* ----------------------------------------
     WEBSOCKET GLOBAL HELPERS (inside startChart)
  -----------------------------------------*/

  function bucket(ts) {
      return Math.floor(ts / (barIntMin * 60)) * (barIntMin * 60);
  }

  window._lastBar = null;
  window._candleSeries = candleSeries;

  // =============================
  // PERFECT 2-WAY SYNC SCROLL + ZOOM (NO LOCKING)
  // =============================

  let syncingFromPrice = false;
  let syncingFromMacd  = false;

  // PRICE ‚Üí MACD
  priceChart.timeScale().subscribeVisibleLogicalRangeChange((logicalRange) => {
      if (syncingFromMacd || !logicalRange) return;

      syncingFromPrice = true;
      try {
          macdChart.timeScale().setVisibleLogicalRange(logicalRange);
      } catch (e) {}
      syncingFromPrice = false;
  });

  // MACD ‚Üí PRICE
  macdChart.timeScale().subscribeVisibleLogicalRangeChange((logicalRange) => {
      if (syncingFromPrice || !logicalRange) return;

      syncingFromMacd = true;
      try {
          priceChart.timeScale().setVisibleLogicalRange(logicalRange);
      } catch (e) {}
      syncingFromMacd = false;
  });
  
// ‚≠ê FINAL FIX: force autoscale after loading all series
setTimeout(() => {
    try {
        priceChart.timeScale().fitContent();
        priceChart.priceScale("right").applyOptions({ autoScale: true });
    } catch(e) { console.log("Autoscale error", e); }
}, 100);

}  // close startChart()

function connectWS() {
    if (!window.initialToken) {
        console.log("‚õî No token ‚Üí cannot start WS");
        return;
    }

    console.log("üîå Connecting WS:", window.wsUrl);
    const ws = new WebSocket(window.wsUrl);

    ws.onopen = () => {
        console.log("üì° WS OPEN ‚Üí subscribing‚Ä¶");
        ws.send(JSON.stringify({ type: "subscribe", token: window.initialToken }));
    };

    ws.onmessage = (ev) => {
        let p;
        try { p = JSON.parse(ev.data); } catch (e) { return; }
        if (!p) return;

        const price = Number(p.lp ?? p.ltp ?? p.price);
        if (!price) return;

        let ts = Number(p.ft ?? p.time ?? p.lts);
        if (ts > 1e12) ts = Math.floor(ts / 1000);

        const barIntMin = Number(window.barInterval || 1);
        const t = bucket(ts);

        // ---- CANDLE CREATION ----
        if (!window._lastBar || t !== window._lastBar.time) {
            window._lastBar = { time:t, open:price, high:price, low:price, close:price };
        } else {
            window._lastBar.high  = Math.max(window._lastBar.high,  price);
            window._lastBar.low   = Math.min(window._lastBar.low,   price);
            window._lastBar.close = price;
        }

        window._candleSeries.update(window._lastBar);

        // ---- LIVE INDICATORS ----
        if (p.pacU !== undefined) pacU.update({ time: t, value: p.pacU });
        if (p.pacL !== undefined) pacL.update({ time: t, value: p.pacL });
        if (p.pacC !== undefined) pacC.update({ time: t, value: p.pacC });

        if (p.tr1 !== undefined) trail1.update({ time: t, value: p.tr1 });
        if (p.tr2 !== undefined) trail2.update({ time: t, value: p.tr2 });

        if (p.macd_hist !== undefined)
            macdHistSeries.update({ time: t, value: p.macd_hist });

        if (p.macd !== undefined)
            macdLineSeries.update({ time: t, value: p.macd });

        if (p.macd_signal !== undefined)
            macdSignalSeries.update({ time: t, value: p.macd_signal });
    };

    ws.onclose = () => {
        console.log("‚ö† WS CLOSED ‚Üí retry in 1s");
        setTimeout(connectWS, 1000);
    };
}

</script>

<!-- Python injects data here -->
<script>
  /*INJECT_DATA*/
</script>

<script>
// Wait until Python injects variables, THEN start chart
function bootChart() {
    if (
        window.initialHistory &&
        Array.isArray(window.initialHistory) &&
        window.initialHistory.length > 0 &&
        window.initialToken &&
        window.wsUrl
    ) {
        console.log("üöÄ Injection complete ‚Üí starting chart");
        startChart();
        connectWS();
    } else {
        console.log("‚è≥ Waiting for inject...");
        setTimeout(bootChart, 300);
    }
}

bootChart();   // Start waiting
</script> 
  
</body>
</html>


























