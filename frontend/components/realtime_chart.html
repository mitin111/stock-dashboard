<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Realtime Chart</title>

  <script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>

  <style>
    html, body { margin: 0; padding: 0; background: #000; overflow: hidden; }
    #price-chart { width: 100vw; height: 450px; }
    #macd-chart  { width: 100vw; height: 180px; margin-top:4px; }
  </style>
</head>

<body>

  <!-- PRICE CHART -->
  <div id="price-chart"></div>

  <!-- MACD CHART -->
  <div id="macd-chart"></div>

  <!-- Python will inject -->
  /*INJECT_DATA*/

<script>
/* ----------------------------------------
   Wait until Python injects history + wsUrl + token
-----------------------------------------*/
function waitForDataAndStart() {
  if (!window.initialHistory ||
      !Array.isArray(window.initialHistory) ||
      window.initialHistory.length === 0) {

    console.log("â³ Waiting for Python injection...");
    return setTimeout(waitForDataAndStart, 300);
  }
  startChart();
}
waitForDataAndStart();

/* ----------------------------------------
   MAIN CHART FUNCTION
-----------------------------------------*/
function startChart() {

  const history    = window.initialHistory || [];
  const wsUrl      = window.wsUrl || "wss://backend-stream-nmlf.onrender.com/ws/live";
  const initialTok = window.initialToken || "";
  const barIntMin  = Number(window.barInterval || 1);

  console.log("Injected history:", history.length);
  console.log("wsUrl:", wsUrl);
  console.log("initialToken:", initialTok);

  const safe = v => (v === null || v === undefined || isNaN(v) ? null : Number(v));

  /* ----------------------------------------
          ðŸ”µ TOP PRICE CHART
  ----------------------------------------*/
  const priceChart = LightweightCharts.createChart(
    document.getElementById('price-chart'),
    {
      layout: { background:{color:'#000'}, textColor:'#fff' },
      grid: { vertLines:{color:'#222'}, horzLines:{color:'#222'} },
      timeScale:{ timeVisible:true }
    }
  );

  const candleSeries = priceChart.addCandlestickSeries({
    upColor:'#26a69a',
    downColor:'#ef5350',
    borderUpColor:'#26a69a',
    borderDownColor:'#ef5350',
    wickUpColor:'#26a69a',
    wickDownColor:'#ef5350'
  });

  const pacU = priceChart.addLineSeries({ color:'#808080', lineWidth:1 });
  const pacL = priceChart.addLineSeries({ color:'#808080', lineWidth:1 });
  const pacC = priceChart.addLineSeries({ color:'#00FFFF', lineWidth:2 });
  const trail1 = priceChart.addLineSeries({ color:'#FF00FF', lineWidth:1 });
  const trail2 = priceChart.addLineSeries({ color:'#00FFFF', lineWidth:1.5 });

 
  /* ----------------------------------------
          ðŸ”´ BOTTOM MACD CHART
  ----------------------------------------*/
 
  const macdChart = LightweightCharts.createChart(
      document.getElementById('macd-chart'),
      {
        layout:{ background:{color:'#000'}, textColor:'#fff' },
        grid:{ vertLines:{color:'#222'}, horzLines:{color:'#222'} },

        timeScale:{ timeVisible:true },

        rightPriceScale:{ visible:true, autoScale:true },

        // ðŸ”¥ Allow user to move MACD chart
        handleScroll:{
            mouseWheel:true,
            pressedMouseMove:true    // â­ allow drag
        },
        handleScale:{
            axisPressedMouseMove:true,
            mouseWheel:true,
            pinch:true
        }
      }
  );


  const macdHistSeries   = macdChart.addHistogramSeries({ base:0 });
  const macdLineSeries   = macdChart.addLineSeries({ color:'#00FFFF', lineWidth:1.5 });
  const macdSignalSeries = macdChart.addLineSeries({ color:'#FF00FF', lineWidth:1.5 });

  /* ----------------------------------------
     LOAD FULL HISTORY
  -----------------------------------------*/
  candleSeries.setData(history.map(c => ({
    time:c.time,
    open:c.open,
    high:c.high,
    low:c.low,
    close:c.close
  })));

  pacU.setData(history.map(c => ({ time:c.time, value:safe(c.pacU) })));
  pacL.setData(history.map(c => ({ time:c.time, value:safe(c.pacL) })));
  pacC.setData(history.map(c => ({ time:c.time, value:safe(c.pacC) })));
  trail1.setData(history.map(c => ({ time:c.time, value:safe(c.Trail1) })));
  trail2.setData(history.map(c => ({ time:c.time, value:safe(c.Trail2) })));

  macdHistSeries.setData(history.map(c => ({
    time:c.time,
    value:safe(c.macd_hist),
    color:(c.macd_hist >= 0 ? '#00FF00' : '#FF0000')
  })));

  macdLineSeries.setData(history.map(c => ({ time:c.time, value:safe(c.macd) })));
  macdSignalSeries.setData(history.map(c => ({ time:c.time, value:safe(c.macd_signal) })));

  // =============================
  // PERFECT 2-WAY SYNC SCROLL + ZOOM
  // =============================

  // --- prevent infinite loop flags ---
  let syncingFromPrice = false;
  let syncingFromMacd  = false;

  // --- PRICE â†’ MACD ---
  priceChart.timeScale().subscribeVisibleTimeRangeChange((range) => {
      if (syncingFromMacd) return;
      syncingFromPrice = true;
      try {
          if (range) macdChart.timeScale().setVisibleRange(range);
      } catch (e) {}
      syncingFromPrice = false;
  });

  // --- MACD â†’ PRICE ---
  macdChart.timeScale().subscribeVisibleTimeRangeChange((range) => {
      if (syncingFromPrice) return;
      syncingFromMacd = true;
      try {
          if (range) priceChart.timeScale().setVisibleRange(range);
      } catch (e) {}
      syncingFromMacd = false;
  });

  /* ----------------------------------------
     REALTIME WEBSOCKET HANDLING
  -----------------------------------------*/

  function bucket(ts) {
    return Math.floor(ts / (barIntMin * 60)) * (barIntMin * 60);
  }

  let lastBar = null;

  function connectWS() {

    let ws = new WebSocket(wsUrl);

    ws.onopen = () => {
      console.log("WS OPEN");
      ws.send(JSON.stringify({ type:"subscribe", token: initialTok }));
    };

    ws.onmessage = (ev) => {
      const p = JSON.parse(ev.data);
      if (!p) return;

      const price = Number(p.lp ?? p.ltp ?? p.price);
      let ts = Number(p.ft ?? p.time ?? p.lts);
      if (!price || !ts) return;

      if (ts > 1e12) ts = Math.floor(ts / 1000);

      const t = bucket(ts);

      if (!lastBar || t !== lastBar.time) {
        lastBar = { time:t, open:price, high:price, low:price, close:price };
        candleSeries.update(lastBar);
      } else {
        lastBar.high = Math.max(lastBar.high, price);
        lastBar.low  = Math.min(lastBar.low,  price);
        lastBar.close = price;
        candleSeries.update(lastBar);
      }

      // Optional indi live update if backend sends them
      if (p.pacU !== undefined) pacU.update({ time:t, value:p.pacU });
      if (p.pacL !== undefined) pacL.update({ time:t, value:p.pacL });
      if (p.pacC !== undefined) pacC.update({ time:t, value:p.pacC });

      if (p.tr1 !== undefined) trail1.update({ time:t, value:p.tr1 });
      if (p.tr2 !== undefined) trail2.update({ time:t, value:p.tr2 });

      if (p.macd_hist !== undefined)
        macdHistSeries.update({ time:t, value:p.macd_hist });

      if (p.macd !== undefined)
        macdLineSeries.update({ time:t, value:p.macd });

      if (p.macd_signal !== undefined)
        macdSignalSeries.update({ time:t, value:p.macd_signal });
    };

    ws.onclose = () => {
      console.log("WS CLOSED â†’ retry in 1s");
      setTimeout(connectWS, 1000);
    };
  }

  if (initialTok) connectWS();
}

</script>

</body>
</html>













