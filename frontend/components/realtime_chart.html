<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Realtime Chart</title>

  <!-- ✅ Correct version & correct standalone bundle -->
  <script type="text/javascript" src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
    }
    #chart-container {
      width: 100vw;
      height: 650px;
    }
  </style>
</head>

<body>
  <div id="chart-container"></div>

<script>
let history    = window.initialHistory || [];
let wsUrl      = window.wsUrl || "wss://backend-stream-nmlf.onrender.com/ws/live";
let initialTok = window.initialToken || null;
let barIntMin  = Number(window.barInterval || 1);

const chart = LightweightCharts.createChart(document.getElementById('chart-container'), {
  layout: { background: { color: '#000' }, textColor: '#fff' },
  grid: { vertLines: { color: '#222' }, horzLines: { color: '#222' } },
  timeScale: { timeVisible: true, secondsVisible: false, rightOffset: 3 }
});

const candleSeries = chart.addCandlestickSeries({
  upColor:'#26a69a', downColor:'#ef5350', borderUpColor:'#26a69a', borderDownColor:'#ef5350',
  wickUpColor:'#26a69a', wickDownColor:'#ef5350'
});

candleSeries.setData(history);

function bucketToInterval(tsSec) {
  // Convert tick timestamp → actual JS Date in IST
  const ist = new Date((tsSec + 19800) * 1000); // 19800 seconds = +5:30

  // Floor to interval
  ist.setSeconds(0, 0);
  ist.setMinutes(Math.floor(ist.getMinutes() / barIntMin) * barIntMin);

  // Return back as **UTC epoch seconds** so tradingview aligns correctly
  return Math.floor((ist.getTime() - 19800 * 1000) / 1000);
}


let lastBar = history.length ? { ...history[history.length - 1] } : null;

function subscribeUrlFromWs(wsUrl) {
  const u = new URL(wsUrl);
  u.protocol = (u.protocol === "wss:") ? "https:" : "http:";
  u.pathname = "/subscribe";
  u.search = "";
  return u.toString();
}

async function httpSubscribe(token) {
  await fetch(subscribeUrlFromWs(wsUrl), {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({ tokens: [String(token)] })
  }).catch(()=>{});
}

function connectWS() {
  if (!initialTok) return;
  let ws = new WebSocket(wsUrl);

  ws.onopen = async () => {
    await httpSubscribe(initialTok);
  };

  ws.onmessage = (event) => {
    try {
      const p = JSON.parse(event.data);
      const price = Number(p.lp ?? p.ltp ?? p.price);
      let ts = Number(p.ft ?? p.time ?? p.lts);
      if (!price || !ts) return;
      if (ts > 1e12) ts = Math.floor(ts / 1000);

      const bucket = bucketToInterval(ts);

      if (!lastBar || bucket > lastBar.time) {
        lastBar = { time: bucket, open: price, high: price, low: price, close: price };
      } else {
        lastBar.high = Math.max(lastBar.high, price);
        lastBar.low  = Math.min(lastBar.low, price);
        lastBar.close = price;
      }
      candleSeries.update(lastBar);

    } catch (e) {}
  };

  ws.onclose = () => setTimeout(connectWS, 2000);
}

function safeStartWS() {
  if (!initialTok) return setTimeout(safeStartWS, 1000);
  connectWS();
}
safeStartWS();
</script>

</body>
</html>

