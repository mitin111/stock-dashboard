<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Realtime Chart</title>

  <!-- ‚úÖ Correct version & standalone bundle -->
  <script type="text/javascript" src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
    }
    #chart-container {
      width: 100vw;
      height: 650px;
    }
  </style>
</head>

<body>
  <div id="chart-container"></div>

<script>
let history    = window.initialHistory || [];
let wsUrl      = window.wsUrl || "wss://backend-stream-nmlf.onrender.com/ws/live";
let initialTok = window.initialToken || null;
let barIntMin  = Number(window.barInterval || 1);

// ‚úÖ Create chart
const chart = LightweightCharts.createChart(document.getElementById('chart-container'), {
  layout: { background: { color: '#000' }, textColor: '#fff' },
  grid: { vertLines: { color: '#222' }, horzLines: { color: '#222' } },
  timeScale: { timeVisible: true, secondsVisible: false, rightOffset: 3 }
});

// ‚úÖ Force IST formatting
chart.applyOptions({
  timezone: 'Asia/Kolkata',
  localization: {
    locale: 'en-IN',
    timeFormatter: t => new Date(t * 1000).toLocaleString('en-IN', {
      timeZone: 'Asia/Kolkata', hour12: false
    }),
  },
  timeScale: {
    tickMarkFormatter: t => new Date(t * 1000).toLocaleTimeString('en-IN', {
      timeZone: 'Asia/Kolkata', hour12: false, hour: '2-digit', minute: '2-digit'
    }),
  }
});

// ‚úÖ Candle series
const candleSeries = chart.addCandlestickSeries({
  upColor:'#26a69a', downColor:'#ef5350',
  borderUpColor:'#26a69a', borderDownColor:'#ef5350',
  wickUpColor:'#26a69a', wickDownColor:'#ef5350'
});
candleSeries.setData(history);

// ‚úÖ --- FIXED bucket rounding ---
function bucketToInterval(tsSec) {
  // round down to start of this candle
  const bucket = Math.floor(tsSec / (barIntMin * 60)) * (barIntMin * 60);
  return bucket;
}

// ‚úÖ Reset logic for symbol or timeframe change
let lastBar = null;
let lastToken = initialTok;
let lastInterval = barIntMin;

function resetLastBarIfChanged() {
  if (lastToken !== initialTok || lastInterval !== barIntMin) {
    console.log("üîÅ Reset lastBar due to symbol/timeframe change");
    lastBar = null;
    lastToken = initialTok;
    lastInterval = barIntMin;
    candleSeries.setData(history || []);  // clear old candles, reload history
  }
}

function subscribeUrlFromWs(wsUrl) {
  const u = new URL(wsUrl);
  u.protocol = (u.protocol === "wss:") ? "https:" : "http:";
  u.pathname = "/subscribe";
  u.search = "";
  return u.toString();
}

async function httpSubscribe(token) {
  await fetch(subscribeUrlFromWs(wsUrl), {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({ tokens: [String(token)] })
  }).catch(()=>{});
}

// --- safeStartWS: try start only when initialTok available (prevents errors)
function safeStartWS() {
  if (!initialTok) {
    // token not ready yet ‚Äî retry after 1s
    return setTimeout(safeStartWS, 1000);
  }
  // token ready ‚Üí start
  connectWS();
}
  
function connectWS() {
  if (!initialTok) return;
  let ws = new WebSocket(wsUrl);

  ws.onopen = async () => {
    // Wait 200ms to ensure new history fully loaded
    await new Promise(r => setTimeout(r, 200));
    await httpSubscribe(initialTok);
    console.log("üì° WS opened and subscribed", initialTok);
  };

  ws.onmessage = (event) => {
    try {
      const p = JSON.parse(event.data);
      if (!p || typeof p !== "object") return;

      // ‚úÖ Skip tick if not for this symbol
      const currentToken = String(initialTok.split("|")[1] || "");
      const tickToken = String(p.tk || "");
      if (tickToken && tickToken !== currentToken) return;

      resetLastBarIfChanged();
      if (!history.length && !lastBar) return;

      const price = Number(p.lp ?? p.ltp ?? p.price);
      let ts = Number(p.ft ?? p.time ?? p.lts);
      if (!price || !ts) return;
      if (ts > 1e12) ts = Math.floor(ts / 1000);

      const bucket = bucketToInterval(ts);

      // ‚úÖ Candle rollover & update logic
      if (!lastBar || bucket !== lastBar.time) {
        lastBar = { time: bucket, open: price, high: price, low: price, close: price };
        candleSeries.update(lastBar);
      } else {
        lastBar.high = Math.max(lastBar.high, price);
        lastBar.low  = Math.min(lastBar.low, price);
        lastBar.close = price;
        candleSeries.update(lastBar);
      }

    } catch (e) {
      console.warn("Tick parse error", e);
    }
  };

  ws.onclose = () => {
    console.warn("‚ö†Ô∏è WS closed, retrying...");
    setTimeout(connectWS, 1500);
  };
}

safeStartWS();
</script>

<script>
window.addEventListener('load', () => {

  // === PAC, Trails, MACD overlay ===

  const pacU = chart.addLineSeries({ color: '#808080', lineWidth: 1 });
  const pacL = chart.addLineSeries({ color: '#808080', lineWidth: 1 });
  const pacC = chart.addLineSeries({ color: '#00FFFF', lineWidth: 2 });
  const trail1 = chart.addLineSeries({ color: '#FF00FF', lineWidth: 1 });
  const trail2 = chart.addLineSeries({ color: '#00FFFF', lineWidth: 1.5 });

  // === MACD Subpane ===
  const macdPane = chart.addPane({ height: 100 });
  const macdLine = macdPane.addLineSeries({ color: '#00FFFF', lineWidth: 1 });
  const macdSignal = macdPane.addLineSeries({ color: '#FF00FF', lineWidth: 1, lineStyle: 2 });
  const macdHist = macdPane.addHistogramSeries({ base: 0, color: '#808080' });

  // === Convert history and plot ===
  const candlesData = window.initialHistory.map(c => ({
    time: c.time,
    open: c.open,
    high: c.high,
    low: c.low,
    close: c.close,
    color: c.trm_signal === 'Buy' ? '#00FF00'
          : c.trm_signal === 'Sell' ? '#FF0000'
          : '#808080'
  }));
  candleSeries.setData(candlesData);

  // --- Overlay Lines ---
  pacU.setData(window.initialHistory.map(c => ({ time: c.time, value: c.pacU })));
  pacL.setData(window.initialHistory.map(c => ({ time: c.time, value: c.pacL })));
  pacC.setData(window.initialHistory.map(c => ({ time: c.time, value: c.pacC })));
  trail1.setData(window.initialHistory.map(c => ({ time: c.time, value: c.Trail1 })));
  trail2.setData(window.initialHistory.map(c => ({ time: c.time, value: c.Trail2 })));

  // --- MACD Panel Data ---
  macdLine.setData(window.initialHistory.map(c => ({ time: c.time, value: c.macd })));
  macdSignal.setData(window.initialHistory.map(c => ({ time: c.time, value: c.macd_signal })));
  macdHist.setData(window.initialHistory.map(c => ({
    time: c.time,
    value: c.macd_hist,
    color: c.macd_hist >= 0 ? '#00FF00' : '#FF0000'
  })));

});
</script>
