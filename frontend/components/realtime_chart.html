<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Realtime Chart</title>
  <script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>
  <style>
    html, body { margin: 0; padding: 0; background: #000; overflow: hidden; }
    #chart-container { width: 100vw; height: 650px; }
  </style>
</head>

<body>
  <div id="chart-container"></div>

<script>
// === Wait for data injection from Python ===
function waitForDataAndStart() {
  if (!window.initialHistory || !Array.isArray(window.initialHistory)) {
    console.log("â³ waiting for Python data...");
    return setTimeout(waitForDataAndStart, 300);
  }
  startChart(); // âœ… start only when data ready
}

function startChart() {
  console.log("âœ… Data received:", window.initialHistory.length, "candles");

  // === Global Data ===
  const history    = window.initialHistory || [];
  const wsUrl      = window.wsUrl || "wss://backend-stream-nmlf.onrender.com/ws/live";
  const initialTok = window.initialToken || null;
  const barIntMin  = Number(window.barInterval || 1);

  // === Create Chart ===
  const chart = LightweightCharts.createChart(document.getElementById('chart-container'), {
    layout: { background: { color: '#000' }, textColor: '#fff' },
    grid: { vertLines: { color: '#222' }, horzLines: { color: '#222' } },
    timeScale: { timeVisible: true, secondsVisible: false, rightOffset: 3 },
    localization: {
      locale: 'en-IN',
      timeFormatter: t => new Date(t * 1000).toLocaleString('en-IN', { timeZone: 'Asia/Kolkata', hour12: false }),
    },
  });
  chart.applyOptions({
    timezone: 'Asia/Kolkata',
    timeScale: {
      tickMarkFormatter: t => new Date(t * 1000).toLocaleTimeString('en-IN', {
        timeZone: 'Asia/Kolkata', hour12: false, hour: '2-digit', minute: '2-digit'
      }),
    }
  });

// === Candle Series (Main Price Scale) ===
const candleSeries = chart.addCandlestickSeries({
  upColor: '#26a69a',
  downColor: '#ef5350',
  borderUpColor: '#26a69a',
  borderDownColor: '#ef5350',
  wickUpColor: '#26a69a',
  wickDownColor: '#ef5350',
  priceScaleId: 'main',
  scaleMargins: { top: 0.05, bottom: 0.25 } // space for MACD
});

// === PAC / Trails ===
const pacU = chart.addLineSeries({ color: '#808080', lineWidth: 1, priceScaleId: 'main' });
const pacL = chart.addLineSeries({ color: '#808080', lineWidth: 1, priceScaleId: 'main' });
const pacC = chart.addLineSeries({ color: '#00FFFF', lineWidth: 2, priceScaleId: 'main' });
const trail1 = chart.addLineSeries({ color: '#FF00FF', lineWidth: 1, priceScaleId: 'main' });
const trail2 = chart.addLineSeries({ color: '#00FFFF', lineWidth: 1.5, priceScaleId: 'main' });

// === MACD (Separate Price Scale) ===
const macdHist = chart.addHistogramSeries({
  priceScaleId: 'macd',
  color: '#808080',
  base: 0,
  scaleMargins: { top: 0.80, bottom: 0.02 } // bottom 20% of chart
});
const macdLine = chart.addLineSeries({
  color: '#00FFFF',
  lineWidth: 1.5,
  priceScaleId: 'macd',
  scaleMargins: { top: 0.80, bottom: 0.02 }
});
const macdSignal = chart.addLineSeries({
  color: '#FF00FF',
  lineWidth: 1.5,
  lineStyle: 2,
  priceScaleId: 'macd',
  scaleMargins: { top: 0.80, bottom: 0.02 }
});

// === Chart Layout Fix (Define both price scales explicitly) ===
chart.applyOptions({
  layout: {
    background: { color: '#000' },
    textColor: '#fff'
  },
  rightPriceScale: {
    visible: true,
    borderVisible: true,
    scaleMargins: { top: 0.05, bottom: 0.25 } // candle + overlay space
  },
  leftPriceScale: {
    visible: true,  // âœ… enable left scale for MACD
    scaleMargins: { top: 0.80, bottom: 0.02 } // MACD area
  },
  timeScale: {
    borderVisible: false,
    rightOffset: 8
  }
});

// === Apply Historical Data ===
if (history.length > 0) {
  const safe = v => (v === null || v === undefined ? NaN : v);

  // Candles
  candleSeries.setData(
    history.map(c => ({
      time: c.time,
      open: c.open,
      high: c.high,
      low: c.low,
      close: c.close,
      color: c.trm_signal === 'Buy' ? '#00FF00'
            : c.trm_signal === 'Sell' ? '#FF0000' : '#808080'
    }))
  );

  // PAC + Trails
  pacU.setData(history.map(c => ({ time: c.time, value: safe(c.pacU) })));
  pacL.setData(history.map(c => ({ time: c.time, value: safe(c.pacL) })));
  pacC.setData(history.map(c => ({ time: c.time, value: safe(c.pacC) })));
  trail1.setData(history.map(c => ({ time: c.time, value: safe(c.Trail1) })));
  trail2.setData(history.map(c => ({ time: c.time, value: safe(c.Trail2) })));

  // MACD
  macdLine.setData(history.map(c => ({ time: c.time, value: safe(c.macd) })));
  macdSignal.setData(history.map(c => ({ time: c.time, value: safe(c.macd_signal) })));
  macdHist.setData(
    history.map(c => ({
      time: c.time,
      value: safe(c.macd_hist),
      color: c.macd_hist >= 0 ? '#00FF00' : '#FF0000'
    }))
  );
}

  // === WebSocket Setup ===
  function bucketToInterval(tsSec) {
    return Math.floor(tsSec / (barIntMin * 60)) * (barIntMin * 60);
  }

  let lastBar = null, lastToken = initialTok, lastInterval = barIntMin;
  function resetLastBarIfChanged() {
    if (lastToken !== initialTok || lastInterval !== barIntMin) {
      lastBar = null; lastToken = initialTok; lastInterval = barIntMin;
      candleSeries.setData(history || []);
    }
  }

  function subscribeUrlFromWs(wsUrl) {
    const u = new URL(wsUrl);
    u.protocol = (u.protocol === "wss:") ? "https:" : "http:";
    u.pathname = "/subscribe";
    return u.toString();
  }

  async function httpSubscribe(token) {
    await fetch(subscribeUrlFromWs(wsUrl), {
      method: "POST", headers: {"Content-Type":"application/json"},
      body: JSON.stringify({ tokens: [String(token)] })
    }).catch(()=>{});
  }

  function safeStartWS() {
    if (!initialTok) return setTimeout(safeStartWS, 1000);
    connectWS();
  }

  function connectWS() {
    let ws = new WebSocket(wsUrl);
    ws.onopen = async () => {
      await new Promise(r => setTimeout(r, 200));
      await httpSubscribe(initialTok);
      console.log("ðŸ“¡ WS opened and subscribed", initialTok);
    };
    ws.onmessage = (event) => {
      try {
        const p = JSON.parse(event.data);
        if (!p || typeof p !== "object") return;
        const currentToken = String(initialTok.split("|")[1] || "");
        const tickToken = String(p.tk || "");
        if (tickToken && tickToken !== currentToken) return;
        resetLastBarIfChanged();
        if (!history.length && !lastBar) return;
        const price = Number(p.lp ?? p.ltp ?? p.price);
        let ts = Number(p.ft ?? p.time ?? p.lts);
        if (!price || !ts) return;
        if (ts > 1e12) ts = Math.floor(ts / 1000);
        const bucket = bucketToInterval(ts);
        if (!lastBar || bucket !== lastBar.time) {
          lastBar = { time: bucket, open: price, high: price, low: price, close: price };
          candleSeries.update(lastBar);
        } else {
          lastBar.high = Math.max(lastBar.high, price);
          lastBar.low  = Math.min(lastBar.low, price);
          lastBar.close = price;
          candleSeries.update(lastBar);
        }
      } catch (e) { console.warn("Tick parse error", e); }
    };
    ws.onclose = () => { setTimeout(connectWS, 1500); };
  }
  safeStartWS();
}

// âœ… Start polling for Python data
waitForDataAndStart();
</script>

</body>
</html>





