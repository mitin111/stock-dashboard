<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>
<style>
  body { margin:0; background:#000; overflow:hidden }
  #chart-container { width:100%; height:100vh; }
</style>
</head>
<body>
<div id="chart-container"></div>

<script>
// ---- Inputs from Streamlit ----
let history    = window.initialHistory || [];
let wsUrl      = window.wsUrl || "wss://backend-stream-nmlf.onrender.com/ws/live";
let initialTok = window.initialToken || null;
let barIntMin  = Number(window.barInterval || 1);

// ---- Chart ----
const chart = LightweightCharts.createChart(document.getElementById('chart-container'), {
  layout: { background: { color: '#000' }, textColor: '#fff' },
  grid: { vertLines: { color: '#222' }, horzLines: { color: '#222' } },
  timeScale: {
    timeVisible: true,
    secondsVisible: false,
    rightOffset: 3,
    tickMarkFormatter: (time) => {
      const ts = (typeof time === 'object' && time.timestamp) ? time.timestamp : time;
      return new Date(ts * 1000).toLocaleString('en-IN', {
        timeZone: 'Asia/Kolkata', hour12: false, hour: '2-digit', minute: '2-digit',
        day: '2-digit', month: '2-digit'
      });
    },
  },
  crosshair: { mode: 1 },
  localization: {
    timeFormatter: (ts) =>
      new Date((ts.timestamp ?? ts) * 1000).toLocaleString('en-IN', { timeZone: 'Asia/Kolkata', hour12: false })
  }
});

const candleSeries = chart.addCandlestickSeries({
  upColor:'#26a69a', downColor:'#ef5350', borderUpColor:'#26a69a', borderDownColor:'#ef5350',
  wickUpColor:'#26a69a', wickDownColor:'#ef5350'
});
candleSeries.setData(history);

// ---- Helper: candle bucket ----
function bucketToInterval(tsSec) {
  const dUTC = new Date(tsSec * 1000);
  const istMs = dUTC.getTime() + 330 * 60 * 1000;
  const ist = new Date(istMs);
  ist.setSeconds(0, 0);
  const m = ist.getMinutes();
  ist.setMinutes(Math.floor(m / barIntMin) * barIntMin);
  const backUTCms = ist.getTime() - 330 * 60 * 1000;
  return Math.floor(backUTCms / 1000);
}

// ---- WebSocket ----
let ws = null;
if (initialTok && initialTok !== "null" && initialTok !== "") {
  ws = new WebSocket(wsUrl);
}

if (ws) {
  ws.onopen = () => {
    console.log("âœ… LW WS Connected:", wsUrl);
    ws.send(JSON.stringify({ action: "subscribe", tokens: [initialTok] }));
  };

  ws.onmessage = (event) => {
    try {
      const p = JSON.parse(event.data);
      const price = Number(p.lp || p.ltp || p.price);
      let ts = Number(p.ft || p.time || p.lts);
      if (!price || !ts) return;
      if (ts > 1e12) ts = Math.floor(ts / 1000);
      const tBucket = bucketToInterval(ts);
      candleSeries.update({ time: tBucket, open: price, high: price, low: price, close: price });
    } catch (e) { console.log("âš ï¸ Tick parse error:", e); }
  };

  ws.onclose = () => {
    console.log("ðŸ”Œ WS Closed â€” Reconnectingâ€¦");
    setTimeout(() => { ws = new WebSocket(wsUrl); }, 2000);
  };
}
</script>
</body>
</html>
