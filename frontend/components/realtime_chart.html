<script>
let history    = window.initialHistory || [];
let wsUrl      = window.wsUrl || "wss://backend-stream-nmlf.onrender.com/ws/live";
let initialTok = window.initialToken || null;
let barIntMin  = Number(window.barInterval || 1);

// âœ… Create chart
const chart = LightweightCharts.createChart(document.getElementById('chart-container'), {
  layout: { background: { color: '#000' }, textColor: '#fff' },
  grid: { vertLines: { color: '#222' }, horzLines: { color: '#222' } },
  timeScale: { timeVisible: true, secondsVisible: false, rightOffset: 3 }
});

// âœ… Force IST
chart.applyOptions({
  timezone: 'Asia/Kolkata',
  localization: {
    locale: 'en-IN',
    timeFormatter: t => new Date(t*1000).toLocaleString('en-IN',{timeZone:'Asia/Kolkata',hour12:false})
  },
  timeScale: {
    tickMarkFormatter: t => new Date(t*1000).toLocaleTimeString('en-IN',{timeZone:'Asia/Kolkata',hour12:false,hour:'2-digit',minute:'2-digit'})
  }
});

// âœ… Candle series
const candleSeries = chart.addCandlestickSeries({
  upColor:'#26a69a', downColor:'#ef5350',
  borderUpColor:'#26a69a', borderDownColor:'#ef5350',
  wickUpColor:'#26a69a', wickDownColor:'#ef5350'
});
candleSeries.setData(history);

// âœ… Bucket calc
function bucketToInterval(tsSec) {
  const d = new Date(tsSec * 1000);
  d.setSeconds(0,0);
  d.setMinutes(Math.floor(d.getMinutes()/barIntMin)*barIntMin);
  return Math.floor(d.getTime()/1000);
}

let lastBar = history.length ? { ...history[history.length - 1] } : null;

// âœ… GLOBAL WebSocket (fixes your problem)
let ws;

async function httpSubscribe(){
  const url = wsUrl.replace("/ws/live","/subscribe");
  console.log("ğŸ”— Subscribing token:", initialTok);
  await fetch(url,{
    method:"POST",
    headers:{"Content-Type":"application/json"},
    body:JSON.stringify({tokens:[String(initialTok)]})
  }).catch(()=>{});
}

function connectWS() {
  ws = new WebSocket(wsUrl);

  ws.onopen = async () => {
    console.log("âœ… WS Connected");
    await httpSubscribe();
  };

  ws.onmessage = (event) => {
    const p = JSON.parse(event.data);
    const price = Number(p.lp ?? p.ltp ?? p.price);
    let ts = Number(p.ft ?? p.time ?? p.lts);
    if (!price || !ts) return;
    if (ts > 1e12) ts = Math.floor(ts/1000);

    const bucket = bucketToInterval(ts);

    if (!lastBar || bucket > lastBar.time) {
      lastBar = { time:bucket, open:price, high:price, low:price, close:price };
    } else {
      lastBar.high = Math.max(lastBar.high, price);
      lastBar.low  = Math.min(lastBar.low, price);
      lastBar.close = price;
    }
    candleSeries.update(lastBar);
  };

  ws.onclose = () => {
    console.log("âš ï¸ WS Closed â€” reconnecting...");
    setTimeout(connectWS, 2000);
  };

  ws.onerror = (err) => console.log("âŒ WS Error:", err);
}

function safeStartWS() {
  if (!initialTok) return setTimeout(safeStartWS, 1000);
  console.log("ğŸš€ Starting WebSocket with:", initialTok);
  connectWS();
}
safeStartWS();
</script>
